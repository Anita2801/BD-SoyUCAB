--Triggers
CREATE OR REPLACE FUNCTION fn_insert_relacion_simetrica()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.Tipo_Relacion = 'Amistad' THEN
        
        IF NOT EXISTS (
            SELECT 1 FROM Se_Relaciona
            WHERE Usuario_Receptor = NEW.Usuario_Solicitante
              AND Usuario_Solicitante = NEW.Usuario_Receptor
        ) THEN
            INSERT INTO Se_Relaciona
            (Usuario_Receptor, Usuario_Solicitante, Tipo_Relacion, Fecha_Relacion)
            VALUES
            (NEW.Usuario_Solicitante, NEW.Usuario_Receptor, 'Amistad', NEW.Fecha_Relacion);
        END IF;

    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER trg_relacion_simetrica
AFTER INSERT ON Se_Relaciona
FOR EACH ROW
EXECUTE FUNCTION fn_insert_relacion_simetrica();

--Constraints
--Tipos de grupo
ALTER TABLE Grupo
ADD CONSTRAINT ck_tipo_grupo
CHECK (Tipo_Grupo IN ('Público', 'Privado'));

--Miembros del chat

--Grupo Participa

--Stored Procedure
CREATE OR REPLACE PROCEDURE sugerir_candidatos(
    p_carrera VARCHAR
)
LANGUAGE plpgsql
AS $$
BEGIN
    SELECT 
        p.CI,
        p.Persona_Usuario AS usuario,
        p.Primer_Nombre || ' ' || p.Primer_Apellido AS nombre,
        COUNT(h.Habilidad) AS coincidencias_hab
    FROM Persona p
    JOIN Nexo n ON n.CI_Nexo = p.CI
    LEFT JOIN Capacidad_Hab h ON h.CI = p.CI
    WHERE n.Cod_Inst_Nexo = p_carrera
    GROUP BY p.CI, p.Persona_Usuario, p.Primer_Nombre, p.Primer_Apellido
    ORDER BY coincidencias_hab DESC;
END;
$$;

--Función
CREATE OR REPLACE FUNCTION fn_es_miembro(
    p_usuario VARCHAR,
    p_grupo VARCHAR
)
RETURNS BOOLEAN AS $$
DECLARE
    existe INT;
BEGIN
    SELECT COUNT(*) INTO existe
    FROM Grupo_Participa
    WHERE Nombre_Grupo = p_grupo
      AND Usuario_Miembro = p_usuario;

    RETURN existe > 0;
END;
$$ LANGUAGE plpgsql;

--Vistas Reportes
-- Crecimiento de la Comunidad.
CREATE OR REPLACE VIEW vw_crecimiento_comunidad AS
SELECT
    ei.Cod_Inst AS codigo_carrera,
    ei.Nombre_Ent_Inst AS nombre_carrera,
    COUNT(DISTINCT n.CI_Nexo) AS total_miembros
FROM Nexo n
JOIN Entidad_Institucional ei 
    ON ei.Cod_Inst = n.Cod_Inst_Nexo
GROUP BY ei.Cod_Inst, ei.Nombre_Ent_Inst
ORDER BY total_miembros DESC;


-- Rendimiento de Grupos
CREATE OR REPLACE VIEW vw_rendimiento_grupos AS
SELECT
    g.Nombre_Grupo,
    g.Tipo_Grupo,
    COUNT(gp.Usuario_Miembro) AS total_miembros,
    SUM(CASE WHEN gp.Rol_Miembro = 'Fundador' THEN 1 ELSE 0 END) AS fundadores,
    SUM(CASE WHEN gp.Rol_Miembro = 'Moderador' THEN 1 ELSE 0 END) AS moderadores,
    SUM(CASE WHEN gp.Rol_Miembro = 'Miembro' THEN 1 ELSE 0 END) AS miembros
FROM Grupo g
LEFT JOIN Grupo_Participa gp ON g.Nombre_Grupo = gp.Nombre_Grupo
GROUP BY g.Nombre_Grupo, g.Tipo_Grupo
ORDER BY total_miembros DESC;

-- Diáspora y Concentración Profesional.
CREATE OR REPLACE VIEW vw_diaspora_concentracion AS
SELECT
    l.Nombre_L AS ubicacion,
    l.Tipo_L AS tipo_ubicacion,
    COUNT(DISTINCT p.CI) AS total_personas,
    array_agg(DISTINCT d.Des_Rol) AS roles_presentes,
    array_agg(DISTINCT n.Cod_Inst_Nexo) AS carreras_presentes
FROM Persona p
JOIN Lugar l ON p.Ubicacion_Persona = l.ISO_Lugar
LEFT JOIN Desempeña d ON d.CI_Rol = p.CI
LEFT JOIN Nexo n ON n.CI_Nexo = p.CI
GROUP BY l.Nombre_L, l.Tipo_L
ORDER BY total_personas DESC;