ALTER TABLE Se_Relaciona
ADD CONSTRAINT CK_No_Autorelacion
CHECK (Usuario_Receptor <> Usuario_Solicitante);

ALTER TABLE Se_Relaciona
ADD COLUMN estado VARCHAR(15) NOT NULL DEFAULT 'Pendiente',
ADD CONSTRAINT CK_Estado_Relacion CHECK (estado IN ('Pendiente', 'Aceptada', 'Rechazada'));

CREATE TABLE Notificaciones (
    id_notificacion SERIAL PRIMARY KEY,
    id_usuario_destino VARCHAR(15) NOT NULL REFERENCES Usuario(Cuenta),
    mensaje TEXT NOT NULL,
    tipo_alerta VARCHAR(20) NOT NULL,
    fecha_creacion TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE OR REPLACE FUNCTION fn_notificar_cambio_estado()
RETURNS TRIGGER AS $$
DECLARE
    mensaje_notificacion TEXT;
    tipo_alerta_final VARCHAR(20);
BEGIN
    IF (NEW.estado IN ('Aceptada', 'Rechazada')) AND (OLD.estado IS DISTINCT FROM NEW.estado) THEN
        IF NEW.estado = 'Aceptada' THEN
            mensaje_notificacion := 'Tu solicitud de relación ha sido aceptada.';
            tipo_alerta_final := 'Aceptada';
        ELSE
            mensaje_notificacion := 'Tu solicitud de relación ha sido rechazada.';
            tipo_alerta_final := 'Rechazada';
        END IF;

        INSERT INTO Notificaciones (id_usuario_destino, mensaje, tipo_alerta)
        VALUES (NEW.Usuario_Solicitante, mensaje_notificacion, tipo_alerta_final);
        
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_notificar_estado_relacion
AFTER UPDATE ON Se_Relaciona 
FOR EACH ROW
EXECUTE FUNCTION fn_notificar_cambio_estado();

CREATE TABLE Asistencia_Evento (
    Usuario_Asistente VARCHAR(15) NOT NULL,
    Nombre_Evento VARCHAR(30) NOT NULL,
    Fecha_Evento DATE NOT NULL,
    Usuario_Evento_Org VARCHAR(15) NOT NULL, 
    Fecha_Registro TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    Asistencia_Confirmada BOOLEAN DEFAULT TRUE,
    
    PRIMARY KEY (Usuario_Asistente, Nombre_Evento, Fecha_Evento, Usuario_Evento_Org),
    
    CONSTRAINT FK_Usuario_Asistente FOREIGN KEY (Usuario_Asistente) REFERENCES Usuario (Cuenta),
    CONSTRAINT FK_Evento_Asistido FOREIGN KEY (Nombre_Evento, Fecha_Evento, Usuario_Evento_Org) 
    REFERENCES Evento (Nombre_Evento, Fecha_Evento, Usuario_Evento)
);

CREATE OR REPLACE PROCEDURE sp_registrar_asistencia_evento(
    p_nombre_evento VARCHAR(30),
    p_fecha_evento DATE,
    p_usuario_organizador VARCHAR(15),
    p_lista_asistentes VARCHAR(15)[]
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_asistente VARCHAR(15);
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM Evento 
        WHERE Nombre_Evento = p_nombre_evento 
          AND Fecha_Evento = p_fecha_evento 
          AND Usuario_Evento = p_usuario_organizador
    ) THEN
        RAISE EXCEPTION 'El evento especificado no existe.';
    END IF;

    FOREACH v_asistente IN ARRAY p_lista_asistentes
    LOOP
        INSERT INTO Asistencia_Evento (Usuario_Asistente, Nombre_Evento, Fecha_Evento, Usuario_Evento_Org)
        VALUES (v_asistente, p_nombre_evento, p_fecha_evento, p_usuario_organizador)
        ON CONFLICT (Usuario_Asistente, Nombre_Evento, Fecha_Evento, Usuario_Evento_Org) DO NOTHING;
    END LOOP;
    
EXCEPTION
    WHEN others THEN
        RAISE EXCEPTION 'Error al registrar la asistencia: %', SQLERRM;
END;
$$;

CREATE OR REPLACE VIEW reporte_conectividad_red AS
SELECT 
    u.Cuenta AS Usuario,
    COUNT(sr_recibida.Usuario_Solicitante) AS Total_Seguidores,
    COUNT(sr_enviada.Usuario_Receptor) AS Total_Seguidos,
    (COUNT(sr_recibida.Usuario_Solicitante) + COUNT(sr_enviada.Usuario_Receptor)) AS Total_Conexiones
FROM 
    Usuario u
LEFT JOIN 
    Se_Relaciona sr_recibida ON u.Cuenta = sr_recibida.Usuario_Receptor -- Relaciones que recibe
LEFT JOIN 
    Se_Relaciona sr_enviada ON u.Cuenta = sr_enviada.Usuario_Solicitante -- Relaciones que hace
GROUP BY 
    u.Cuenta
ORDER BY 
    Total_Conexiones DESC;
	
CREATE TABLE Denuncia (
    id_denuncia SERIAL PRIMARY KEY,
    usuario_denunciante VARCHAR(15) NOT NULL REFERENCES Usuario(Cuenta),
    usuario_denunciado VARCHAR(15) NOT NULL REFERENCES Usuario(Cuenta),
    motivo VARCHAR(100),
    fecha_denuncia DATE DEFAULT CURRENT_DATE,
    estatus VARCHAR(20) DEFAULT 'Pendiente' CHECK (estatus IN ('Pendiente', 'Revisada', 'Descartada'))
);

-- Insertemos un par de datos falsos para probar el reporte
INSERT INTO Denuncia (usuario_denunciante, usuario_denunciado, motivo) VALUES 
('smpanza.22', 'qdmancha.22', 'Comportamiento errático con molinos'),
('dtoboso.22', 'qdmancha.22', 'Acoso romántico no solicitado');

CREATE OR REPLACE VIEW reporte_actividad_denuncias AS
SELECT 
    usuario_denunciado AS Usuario_Reportado,
    COUNT(*) AS Cantidad_Denuncias,
    STRING_AGG(motivo, ' | ') AS Motivos -- Junta todos los motivos en una sola línea
FROM 
    Denuncia
GROUP BY 
    usuario_denunciado
ORDER BY 
    Cantidad_Denuncias DESC;

SELECT 
    usuario_denunciado AS "Usuario Reportado",
    COUNT(*) AS "Total Denuncias",
    STRING_AGG(motivo, ' | ') AS "Motivos Agrupados" -- Agrupa los motivos para facilitar la lectura
FROM 
    Denuncia
GROUP BY 
    usuario_denunciado
ORDER BY 
    "Total Denuncias" DESC;
	
SELECT 
    u.Cuenta AS "Usuario",
    COUNT(DISTINCT recibida.Usuario_Solicitante) AS "Seguidores",
    COUNT(DISTINCT enviada.Usuario_Receptor) AS "Seguidos",
    (COUNT(DISTINCT recibida.Usuario_Solicitante) + COUNT(DISTINCT enviada.Usuario_Receptor)) AS "Total Conexiones"
FROM 
    Usuario u
LEFT JOIN 
    Se_Relaciona recibida ON u.Cuenta = recibida.Usuario_Receptor   -- Conteo de seguidores (relaciones recibidas)
LEFT JOIN 
    Se_Relaciona enviada ON u.Cuenta = enviada.Usuario_Solicitante   -- Conteo de seguidos (relaciones enviadas)
GROUP BY 
    u.Cuenta
ORDER BY 
    "Total Conexiones" DESC;
	